#!/bin/bash

#              ,---------------------------,
#              |  /---------------------\  |
#              | |                       | |
#              | |     Jack Nemitz       | |
#              | |      .dotfiles        | |
#              | |     bash_prompt       | |
#              | |                       | |
#              |  \_____________________/  |
#              |___________________________|
#            ,---\_____     []     _______/------,
#          /         /______________\           /|
#        /___________________________________ /  | ___
#        |                                   |   |    )
#        |  _ _ _                 [-------]  |   |   (
#        |  o o o                 [-------]  |  /    _)_
#        |__________________________________ |/     /  /
#    /-------------------------------------/|      ( )/
#  /-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/ /
#/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/-/ /
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

T='gYw'   # The test text
 
echo -e "\n                 40m     41m     42m     43m\
     44m     45m     46m     47m";
 
for FGs in '    m' '   1m' '  30m' '1;30m' '  31m' '1;31m' '  32m' \
           '1;32m' '  33m' '1;33m' '  34m' '1;34m' '  35m' '1;35m' \
           '  36m' '1;36m' '  37m' '1;37m';
  do FG=${FGs// /}
  echo -en " $FGs \033[$FG  $T  "
  for BG in 40m 41m 42m 43m 44m 45m 46m 47m;
    do echo -en "$EINS \033[$FG\033[$BG  $T  \033[0m";
  done
  echo;
done
echo

PS1="\e[1;31m<\u>\e[0m \e[1;37m@\e[0m \e[1;34m\w\e[0m\e[1;32m\$(prompt_git)\e[0m - \@\n$ "
export PS1;

# I got this function online but can't remember where. It basically provides information for a git repo in the cmd line prompt when in a git repo. The function is called above in the prompt customization.
prompt_git() {
    local s='';
    local branchName='';

    # Check if the current directory is in a Git repository.
    $(git rev-parse --is-inside-work-tree &>/dev/null);
    if [[ $? == 0 ]]; then
        # Check for what branch we’re on.
        # Get the short symbolic ref. If HEAD isn’t a symbolic ref, get a
        # tracking remote branch or tag. Otherwise, get the
        # short SHA for the latest commit, or give up.
        branchName=" on $(git symbolic-ref --quiet --short HEAD 2> /dev/null || \
            git describe --all --exact-match HEAD 2> /dev/null || \
            git rev-parse --short HEAD 2> /dev/null || \
            echo '(unknown)')";

        # Early exit for Chromium & Blink repo, as the dirty check takes too long.
        # Thanks, @paulirish!
        # https://github.com/paulirish/dotfiles/blob/dd33151f/.bash_prompt#L110-L123
        repoUrl="$(git config --get remote.origin.url)";
        if grep -q 'chromium/src.git' <<< "${repoUrl}"; then
            s+='*';
        else
            # Check for uncommitted changes in the index.
            if ! $(git diff --quiet --ignore-submodules --cached); then
                s+='+';
            fi;
            # Check for unstaged changes.
            if ! $(git diff-files --quiet --ignore-submodules --); then
                s+='!';
            fi;
            # Check for untracked files.
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                s+='?';
            fi;
            # Check for stashed files.
            if $(git rev-parse --verify refs/stash &>/dev/null); then
                s+='$';
            fi;
        fi;

        [ -n "${s}" ] && s=" [${s}]";

    else
        branchName="";
    fi;

    echo -e "${1}${branchName}${2}${s}";

}
